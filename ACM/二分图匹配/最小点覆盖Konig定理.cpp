// 最小覆盖点数=最大匹配数
// 一个直观地找最小覆盖点集的方法：从左侧一个未匹配成功的点出发，走一趟匈牙利算法的流程（即紫色的箭头），所有左侧未经过的点，和右侧经过的点，即组成最小点覆盖。

// 证明:
// 1.实际上就是在一个最大匹配M中，选择每个匹配边的一个被匹配的端点。
// 2.对于一个被匹配的边来说，被匹配的两个端点不可能同时连接着未被匹配的点否则这个匹配可被增广
// 3.所以总是选择匹配边中连接着未匹配点的那个端点即可
// 4.而从左侧未匹配成功的点出发走增广路，可知，右侧第一个点的一定是M中匹配的点，且该点可被选为最小点覆盖的点，因为它的左侧连接了我们的未匹配的点（出发点）
// 5.继续从这个点走增广路，它的下一个点如果是M中匹配的点，那么一定是没有连接未匹配点的，否则可以继续增广
// 6.而左边未被选中的点则是那些在M中匹配边上的左侧端点